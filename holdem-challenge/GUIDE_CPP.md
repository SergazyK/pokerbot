## Вариант 1: компиляция во время запуска

В этом варианте, компиляция будет происходить на тестирующем сервере. При этом не будет проблем с несовместимостью бинарных исполняемых файлов с системой, но время компиляции будет учитываться за время работы.

Предположим, решение написано на C++. Есть общедоступный образ [`library/gcc`](https://hub.docker.com/_/gcc/), содержащий коллекцию компиляторов GCC. Будем компилировать и запускать решение в нем.

Создаем скрипт `run.sh`, который будет компилировать код и запускать собранный исполняемый файл:
```sh
#!/bin/sh

# compilation
g++ main.cpp -o bot

# running
exec ./bot
```

Создаем `metadata.json`:
```json
{
    "image": "library/gcc",
    "entry_point": "sh run.sh"
}
```

## Вариант 2: компиляция перед сабмитом

Этот смособ предполагает, что участник самостоятельно компилирует свое решение на своей машине, а на проверку отправляется исполняемый файл. При этом нужно следить, чтобы исполняемый файл был совместим с образом-окружением, в котором запускается бинарный файл.

Если вы используете операционную систему, для которой есть docker-образ, то необходимо просто скомпилировать свое решение:
```sh
g++ main.cpp -o bot
```

Затем сделать `metadata.json`, указав окружение в соответствии с вашей системой, например:
```json
{
    "image": "ubuntu:16.04",
    "entry_point": "./bot"
}
```

Обратите внимание, что исполняемый файл в архиве должен иметь флаг права на запуск, как правило этот флаг автоматически выставляется при компиляции, но его можно выставить командой:
```
chmod +x bot
```

Если используется операционная система, для которой нет docker-образа, то придется произвести компиляцию у себя на машине, но в одном из доступных docker-окружений. Для этого придется иметь [установленный Docker](https://docs.docker.com/engine/installation/) на своем компьютере. 

Например, будем использовать окружение [`library/gcc`](https://hub.docker.com/_/gcc/). В нем скомпилируем исполняемый файл (на своей машине):
```sh
docker run -v `pwd`:/src -w /src gcc g++ main.cpp -o bot
```

И в нем же будем запускать бота:
```json
{
    "image": "library/gcc",
    "entry_point": "./bot"
}
```

## Проверка бота перед отправкой

Проверку кода своего бота можно осуществить без отправки в систему, так вы получите больше представления о характере ошибки, если что-то пойдет не так. Для этого нужно [установить Docker](https://docs.docker.com/engine/installation/).

Для этого, используйте [этот код запуска бота против рандомных](https://gist.github.com/romovpa/a96b2d2622a3a4a014ea2fb6256445ab). При этом командную строку необходимо сделать примерно следующей:
```
player = ExternalExecutablePlayer('docker run --rm -i -m 2g --cpus 1 --network none -v /home/user/bot_code:/workspace -w /workspace library/gcc ./bot')
```

Именно таким образом бот запускается на проверяющей машине.
